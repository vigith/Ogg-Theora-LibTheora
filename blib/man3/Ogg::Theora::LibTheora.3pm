.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Ogg::Theora::LibTheora 3"
.TH Ogg::Theora::LibTheora 3 "2011-04-06" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Ogg::Theora::LibTheora \- XS Interface for calling Theora Video Codec functions in Perl.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Ogg::Theora::LibTheora is a glue between theora/theora.h theora/theoraenc.h and theora/theoradec.h . 
.SH "SYNOPSIS ENCODE"
.IX Header "SYNOPSIS ENCODE"
.Vb 2
\&  ## constants are exported by DEFAULT
\&  use Ogg::Theora::LibTheora ':all'; # to export everything to current namespace
.Ve
.PP
Encoding raw \s-1RGB\s0 files to create a theora video file.
.PP
.Vb 2
\&  use Ogg::Theora::LibTheora;
\&  use Ogg::LibOgg ':all';
.Ve
.PP
.Vb 4
\&  my $op = make_ogg_packet();
\&  my $og = make_ogg_page();
\&  my $os = make_ogg_stream_state();
\&  my $oy = make_ogg_sync_state();
.Ve
.PP
.Vb 2
\&  ogg_sync_init($oy); ## should be == 0
\&  ogg_stream_init($os, 10101); ## should be == 0 and 10101 is a random serial number
.Ve
.PP
.Vb 10
\&  #########################################################################################################
\&  # (1) Fill in a th_info structure with details on the format of the video you wish to encode.           #
\&  # (2) Allocate a th_enc_ctx handle with th_encode_alloc().                                              #
\&  # (3) Perform any additional encoder configuration required with th_encode_ctl().                       #
\&  # (4) Repeatedly call th_encode_flushheader() to retrieve all the header packets.                       #
\&  # (5) For each uncompressed frame:                                                                      #
\&  #        (5.a) Submit the uncompressed frame via th_encode_ycbcr_in()                                   #
\&  #        (5.b) Repeatedly call th_encode_packetout() to retrieve any video data packets that are ready. #
\&  # (6) Call th_encode_free() to release all encoder memory.                                              #
\&  #########################################################################################################
.Ve
.PP
.Vb 3
\&  my $th_setup_info_addr = 0;
\&  my $th_info = Ogg::Theora::LibTheora::make_th_info();
\&  Ogg::Theora::LibTheora::th_info_init($th_info);
.Ve
.PP
.Vb 2
\&  my $w = 320;                  # width
\&  my $h = 240;                  # height
.Ve
.PP
.Vb 1
\&  Ogg::Theora::LibTheora::set_th_info($th_info, {'frame_width' => $w, 'frame_height' => $h});
.Ve
.PP
.Vb 4
\&  my $th_comment = Ogg::Theora::LibTheora::make_th_comment();
\&  Ogg::Theora::LibTheora::th_comment_init($th_comment);
\&  Ogg::Theora::LibTheora::th_comment_add($th_comment, "title=test video");
\&  Ogg::Theora::LibTheora::th_comment_init($th_comment);
.Ve
.PP
.Vb 3
\&  my $filename = "t/theora_encode.ogg";
\&  open OUT, ">", "$filename" or die "can't open $filename for writing [$!]";
\&  binmode OUT;
.Ve
.PP
.Vb 1
\&  my $th_enc_ctx = Ogg::Theora::LibTheora::th_encode_alloc($th_info);
.Ve
.PP
.Vb 9
\&  my $status = 1;
\&  do {
\&    $status = Ogg::Theora::LibTheora::th_encode_flushheader($th_enc_ctx, $th_comment, $op);
\&    if ($status > 0) {
\&      ogg_stream_packetin($os, $op) == 0 or warn "ogg_stream_packetin returned -1\en"
\&    } elsif ($status == Ogg::Theora::LibTheora::TH_EFAULT) {
\&      warn "TH_EFAULT\en"
\&    }
\&  } while ($status != 0);
.Ve
.PP
.Vb 1
\&  save_page();
.Ve
.PP
.Vb 5
\&  foreach ((1..5)) {
\&    add_image("t/enc_pic1.raw");  ## raw files are raw RGB data files
\&    add_image("t/enc_pic2.raw");
\&    add_image("t/enc_pic3.raw");
\&  }
.Ve
.PP
.Vb 1
\&  ogg_stream_flush($os, $og);
.Ve
.PP
.Vb 1
\&  Ogg::Theora::LibTheora::th_encode_free($th_enc_ctx);
.Ve
.PP
.Vb 9
\&  sub save_page {
\&    ## forms packets to pages 
\&    if (ogg_stream_pageout($os, $og) != 0) {
\&      my $h_page = get_ogg_page($og);
\&      ## writes the header and body 
\&    } else {
\&      # pass, we don't have to worry about insufficient data
\&    }
\&  }
.Ve
.PP
.Vb 7
\&  sub add_image {
\&    my ($name) = shift;
\&    open IN, "$name" or die "can't open [$name] $!\en";
\&    binmode IN;
\&    local $/ = undef;
\&    my $str = <IN>;
\&    close IN;
.Ve
.PP
.Vb 1
\&    Ogg::Theora::LibTheora::rgb_th_encode_ycbcr_in($th_enc_ctx, $str, $w, $h) == 0 or warn ("Error th_encode_ycbcr_in");
.Ve
.PP
.Vb 5
\&    my $n;
\&    do {
\&      $n = Ogg::Theora::LibTheora::th_encode_packetout($th_enc_ctx, 0, $op);
\&      $n == TH_EFAULT and warn ("($n) TH_EFAULT th_encode_packetout");
\&    } while (0);
.Ve
.PP
.Vb 1
\&    ogg_stream_packetin($os, $op) == 0 or warn ("Internal Error 'ogg_stream_packetin");
.Ve
.PP
.Vb 2
\&    save_page();
\&  }
.Ve
.SH "SYNOPSIS DECODE"
.IX Header "SYNOPSIS DECODE"
Decoding a theora video file to generate the raw \s-1RGB\s0 files. (here we generate only 1 raw file)
.PP
.Vb 2
\&  use strict;
\&  use Ogg::LibOgg ':all';
.Ve
.PP
.Vb 1
\&  use Ogg::Theora::LibTheora;
.Ve
.PP
.Vb 5
\&  ## Make Ogg Structures
\&  my $op = make_ogg_packet();
\&  my $og = make_ogg_page();
\&  my $os = make_ogg_stream_state();
\&  my $oy = make_ogg_sync_state();
.Ve
.PP
.Vb 2
\&  my $filename = "t/theora.ogg";
\&  open IN, $filename or die "can't open [$filename] : $!";
.Ve
.PP
.Vb 2
\&  ## Ogg Sync Init
\&  ogg_sync_init($oy);
.Ve
.PP
.Vb 2
\&  ## read a page (wrapper for ogg_sync_pageout)
\&  ogg_read_page(*IN, $oy, $og);
.Ve
.PP
.Vb 1
\&  my $slno = ogg_page_serialno($og);
.Ve
.PP
.Vb 2
\&  ## Initializes the Ogg Stream State struct
\&  ogg_stream_init($os, $slno);
.Ve
.PP
.Vb 3
\&  ## add complete page to the bitstream, o create a valid ogg_page struct
\&  ## after calling ogg_sync_pageout (read_page does ogg_sync_pageout)
\&  ogg_stream_pagein($os, $og);
.Ve
.PP
.Vb 4
\&  my $th_comment = Ogg::Theora::LibTheora::make_th_comment();
\&  Ogg::Theora::LibTheora::th_comment_init($th_comment);
\&  my $th_info = Ogg::Theora::LibTheora::make_th_info();
\&  Ogg::Theora::LibTheora::th_info_init($th_info);
.Ve
.PP
.Vb 10
\&  ###############################################################################################
\&  # (1) Parse the header packets by repeatedly calling th_decode_headerin().                    #
\&  # (2) Allocate a th_dec_ctx handle with th_decode_alloc().                                    #
\&  # (3) Call th_setup_free() to free any memory used for codec setup information.               #
\&  # (4) Perform any additional decoder configuration with th_decode_ctl().                      #
\&  # (5) For each video data packet:                                                             #
\&  #     (5.a) Submit the packet to the decoder via th_decode_packetin().                        #
\&  #     (5.b) Retrieve the uncompressed video data via th_decode_ycbcr_out().                   #
\&  # (6) Call th_decode_free() to release all decoder memory.                                    #
\&  ###############################################################################################
.Ve
.PP
.Vb 5
\&  ## Decode Header and parse the stream till the first VIDEO packet gets in
\&  my $th_setup_info_addr = 0;
\&  my $ret = undef;
\&  Ogg::Theora::LibTheora::th_packet_isheader($op);
\&  Ogg::Theora::LibTheora::th_packet_iskeyframe($op);
.Ve
.PP
.Vb 5
\&  do {
\&    ($ret, $th_setup_info_addr) = Ogg::Theora::LibTheora::th_decode_headerin($th_info, $th_comment, $th_setup_info_addr, $op);
\&    ## $ret > 0 indicates that a Theora header was successfully processed.
\&    readPacket() if $ret != 0;
\&  } while ($ret != 0); ## ret == 0 means, first video data packet was encountered
.Ve
.PP
.Vb 2
\&  ## th_decode_alloc
\&  my $th_dec_ctx = Ogg::Theora::LibTheora::th_decode_alloc($th_info, $th_setup_info_addr);
.Ve
.PP
.Vb 2
\&  ## th_setup_free
\&  Ogg::Theora::LibTheora::th_setup_free($th_setup_info_addr);
.Ve
.PP
.Vb 2
\&  ## Make th_ycbcr_buffer
\&  my $th_ycbcr_buffer = Ogg::Theora::LibTheora::make_th_ycbcr_buffer();
.Ve
.PP
.Vb 4
\&  ## th_decode_packetin
\&  my $gpos = 0;
\&  $ret = undef;
\&  ($ret, $gpos) = Ogg::Theora::LibTheora::th_decode_packetin($th_dec_ctx, $op, $gpos);
.Ve
.PP
.Vb 2
\&  ## th_decode_ycbcr_out
\&  Ogg::Theora::LibTheora::th_decode_ycbcr_out($th_dec_ctx, $th_ycbcr_buffer);
.Ve
.PP
.Vb 1
\&  my $rgb_buf = Ogg::Theora::LibTheora::ycbcr_to_rgb_buffer($th_ycbcr_buffer);
.Ve
.PP
.Vb 4
\&  open OUT, ">", "t/dec_pic1.raw" or diag( "can't open $!");
\&  binmode OUT;
\&  print OUT $rgb_buf;
\&  close OUT;
.Ve
.PP
.Vb 2
\&  ## th_decode_free
\&  Ogg::Theora::LibTheora::th_decode_free($th_dec_ctx);
.Ve
.PP
.Vb 1
\&  Ogg::Theora::LibTheora::th_info_clear($th_info);
.Ve
.PP
.Vb 1
\&  close IN;
.Ve
.PP
.Vb 8
\&  sub readPacket {
\&    while (ogg_stream_packetout($os, $op) == 0) {
\&      if (not defined ogg_read_page(*IN, $oy, $og)) {
\&        return undef
\&      }
\&      ogg_stream_pagein($os, $og);
\&    }
\&  }
.Ve
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.Sh "Exportable constants"
.IX Subsection "Exportable constants"
.Vb 62
\&  OC_BADHEADER
\&  OC_BADPACKET
\&  OC_CS_ITU_REC_470BG
\&  OC_CS_ITU_REC_470M
\&  OC_CS_NSPACES
\&  OC_CS_UNSPECIFIED
\&  OC_DISABLED
\&  OC_DUPFRAME
\&  OC_EINVAL
\&  OC_FAULT
\&  OC_IMPL
\&  OC_NEWPACKET
\&  OC_NOTFORMAT
\&  OC_PF_420
\&  OC_PF_422
\&  OC_PF_444
\&  OC_PF_RSVD
\&  OC_VERSION
\&  TH_CS_ITU_REC_470BG
\&  TH_CS_ITU_REC_470M
\&  TH_CS_NSPACES
\&  TH_CS_UNSPECIFIED
\&  TH_DECCTL_GET_PPLEVEL_MAX
\&  TH_DECCTL_SET_GRANPOS
\&  TH_DECCTL_SET_PPLEVEL
\&  TH_DECCTL_SET_STRIPE_CB
\&  TH_DECCTL_SET_TELEMETRY_BITS
\&  TH_DECCTL_SET_TELEMETRY_MBMODE
\&  TH_DECCTL_SET_TELEMETRY_MV
\&  TH_DECCTL_SET_TELEMETRY_QI
\&  TH_DUPFRAME
\&  TH_EBADHEADER
\&  TH_EBADPACKET
\&  TH_EFAULT
\&  TH_EIMPL
\&  TH_EINVAL
\&  TH_ENCCTL_2PASS_IN
\&  TH_ENCCTL_2PASS_OUT
\&  TH_ENCCTL_GET_SPLEVEL
\&  TH_ENCCTL_GET_SPLEVEL_MAX
\&  TH_ENCCTL_SET_BITRATE
\&  TH_ENCCTL_SET_DUP_COUNT
\&  TH_ENCCTL_SET_HUFFMAN_CODES
\&  TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE
\&  TH_ENCCTL_SET_QUALITY
\&  TH_ENCCTL_SET_QUANT_PARAMS
\&  TH_ENCCTL_SET_RATE_BUFFER
\&  TH_ENCCTL_SET_RATE_FLAGS
\&  TH_ENCCTL_SET_SPLEVEL
\&  TH_ENCCTL_SET_VP3_COMPATIBLE
\&  TH_ENOTFORMAT
\&  TH_EVERSION
\&  TH_NDCT_TOKENS
\&  TH_NHUFFMAN_TABLES
\&  TH_PF_420
\&  TH_PF_422
\&  TH_PF_444
\&  TH_PF_NFORMATS
\&  TH_PF_RSVD
\&  TH_RATECTL_CAP_OVERFLOW
\&  TH_RATECTL_CAP_UNDERFLOW
\&  TH_RATECTL_DROP_FRAMES
.Ve
.SH "Functions (malloc)"
.IX Header "Functions (malloc)"
<http://www.theora.org/doc/libtheora\-1.0/annotated.html>
.SH "make_th_info"
.IX Header "make_th_info"
Creates a memory allocation for th_info.
.PP
\&\-Input:
  Void
.PP
\&\-Output:
  Memory Pointer
.SH "make_th_huff_code"
.IX Header "make_th_huff_code"
Creates a memory allocation for th_huff_code.
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer
.SH "make_th_img_plane"
.IX Header "make_th_img_plane"
Creates a memory allocation for th_img_plane.
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer
.SH "make_th_quant_info"
.IX Header "make_th_quant_info"
Creates a memory allocation for th_quant_info.
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer
.SH "make_th_quant_ranges"
.IX Header "make_th_quant_ranges"
Creates a memory allocation for th_quant_ranges.
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer
.SH "make_th_stripe_callback"
.IX Header "make_th_stripe_callback"
Creates a memory allocation for th_stripe_callback.
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer
.SH "make_th_ycbcr_buffer"
.IX Header "make_th_ycbcr_buffer"
Creates a memory allocation for th_ycbcr_buffer.
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer
.SH "make_th_comment"
.IX Header "make_th_comment"
Creates a memory allocation for th_comment.
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer
.SH "Functions (Basic shared functions)"
.IX Header "Functions (Basic shared functions)"
<http://www.theora.org/doc/libtheora\-1.0/group_\|_basefuncs.html>
.SH "th_version_number"
.IX Header "th_version_number"
Retrieves the library version number. 
.PP
\&\-Input:
  void
.PP
\&\-Output:
  ogg_uint32_t (\s-1IV\s0)
.SH "th_version_string"
.IX Header "th_version_string"
Retrieves a human-readable string to identify the library vendor and version. 
.PP
\&\-Input:
  void
.PP
\&\-Output:
  const char * (T_PV)
.SH "th_packet_isheader"
.IX Header "th_packet_isheader"
Determines whether a Theora packet is a header or not. 
.PP
\&\-Input:
  _op 	An ogg_packet containing encoded Theora data. 
.PP
\&\-Output:
  1 packet is a header packet,
  0 packet is a video data packet. 
.SH "th_granule_frame"
.IX Header "th_granule_frame"
Converts a granule position to an absolute frame index, starting at 0. 
.PP
\&\-Input:
  void * _encdec (previously allocated th_enc_ctx or th_dec_ctx handle),
  ogg_int64_t _granpos (granule position to convert).
.PP
\&\-Output:
  absolute frame index corresponding to _granpos,
  \-1 on error.
.SH "th_granule_time"
.IX Header "th_granule_time"
Converts a granule position to an absolute time in seconds. 
.PP
\&\-Input:
  void * _encdec (previously allocated th_enc_ctx or th_dec_ctx handle),
  ogg_int64_t _granpos (granule position to convert).
.PP
\&\-Output:
  absolute time in seconds corresponding to _granpos,
  \-1 on error.
.SH "th_packet_iskeyframe"
.IX Header "th_packet_iskeyframe"
Determines whether a theora packet is a key frame or not. 
.PP
\&\-Input:
  _op 	An ogg_packet containing encoded Theora data. 
.PP
\&\-Output:
   1 packet is a key frame,
   0 packet is a delta frame,
  \-1 packet is not a video data packet. 
.SH "Functions (Manipulating Header Data)"
.IX Header "Functions (Manipulating Header Data)"
.SH "th_comment_init"
.IX Header "th_comment_init"
Initialize a th_comment structure. 
.PP
\&\-Input:
  th_comment *
.PP
\&\-Output:
  void
.SH "th_info_init"
.IX Header "th_info_init"
Initializes a th_info structure. 
.PP
\&\-Input:
  th_info
.PP
\&\-Output:
  void
.SH "th_info_clear"
.IX Header "th_info_clear"
Clears a th_info structure. 
.PP
\&\-Input:
  th_info
.PP
\&\-Output:
  void
.SH "th_comment_add"
.IX Header "th_comment_add"
Add a comment to an initialized th_comment structure. 
.PP
\&\-Input:
  th_comment,
  char * (null\-terminated \s-1UTF\-8\s0 string containing the comment in \*(L"TAG=the value\*(R" form).
.PP
\&\-Output:
  void
.SH "th_comment_add_tag"
.IX Header "th_comment_add_tag"
Add a comment to an initialized th_comment structure. 
.PP
\&\-Input:
  th_comment,
  char * (null\-terminated string containing the tag associated with the comment),
  char * (corresponding value as a null-terminated string).
.SH "th_comment_query_count"
.IX Header "th_comment_query_count"
Look up the number of instances of a tag.
.PP
\&\-Input:
  th_comment,
  char * (tag to look up).
.PP
\&\-Output:
  int (number on instances of this particular tag)
.SH "th_comment_query"
.IX Header "th_comment_query"
Look up a comment value by its tag. 
.PP
\&\-Input:
  th_comment,
  char * (tag to look\-up)
  int (instance of the tag, it starts from 0)
.PP
\&\-Output:
  char * if matched pointer to the queried tag's value,
  \s-1NULL\s0 if no matching tag is found
.SH "Functions (For Decoding)"
.IX Header "Functions (For Decoding)"
<http://www.theora.org/doc/libtheora\-1.0/group_\|_decfuncs.html>
.SH "th_decode_headerin"
.IX Header "th_decode_headerin"
Decodes the header packets of a Theora stream. 
.PP
\&\-Input:
  th_info,
  th_comment,
  th_setup_info, (initialized to \s-1NULL\s0 on the first call & returned value be passed on subsequent calls)
  ogg_packet
.PP
\&\-Output:
  0 first video data packet was encountered after all required header packets were parsed,
  \s-1TH_EFAULT\s0 if one of _info, _tc, or _setup was \s-1NULL\s0,
  \s-1TH_EBADHEADER\s0 _op was \s-1NULL\s0,
  \s-1TH_EVERSION\s0 not decodable with current libtheoradec version,
  \s-1TH_ENOTFORMAT\s0 not a Theora header
.SH "th_decode_alloc"
.IX Header "th_decode_alloc"
Allocates a decoder instance. 
.PP
\&\-Input:
  th_info,
  th_setup_info
.PP
\&\-Output:
  th_dec_ctx
.SH "th_setup_free"
.IX Header "th_setup_free"
Releases all storage used for the decoder setup information.
.PP
\&\-Input:
  th_setup_info
.PP
\&\-Output:
  void
.SH "th_decode_packetin"
.IX Header "th_decode_packetin"
Submits a packet containing encoded video data to the decoder. 
.PP
\&\-Input:
  th_dec_ctx,
  ogg_packet,
  ogg_int64_t gran_pos, returns the granule position of the decoded packet
.PP
\&\-Output:
  0 success,
  \s-1TH_DUPFRAME\s0 packet represented a dropped (0\-byte) frame,
  \s-1TH_EFAULT\s0 _dec or _op was \s-1NULL\s0,
  \s-1TH_EBADPACKET\s0 _op does not contain encoded video data,
  \s-1TH_EIMPL\s0 video data uses bitstream features which this library does not support.
.SH "th_decode_ycbcr_out"
.IX Header "th_decode_ycbcr_out"
Outputs the next available frame of decoded Y'CbCr data. 
.PP
\&\-Input:
  th_dec_ctx,
  th_ycbcr_buffer (video buffer structure to fill in)
.PP
\&\-Output:
  0 Success
.SH "th_decode_free"
.IX Header "th_decode_free"
Frees an allocated decoder instance. 
.PP
\&\-Input:
  th_dec_ctx
.PP
\&\-Output:
  void
.SH "th_decode_ctl"
.IX Header "th_decode_ctl"
Decoder control function. (i haven't tested this)
.PP
\&\-Input:
  th_dec_ctx,
  int _req (control code to process),
  void * _buf (parameters for this control code),
  size_t _buf_sz (size of the parameter buffer)
.PP
\&\-Output:
  int (not documented)
.SH "Functions (for Encoding)"
.IX Header "Functions (for Encoding)"
<http://www.theora.org/doc/libtheora\-1.0/group_\|_encfuncs.html>
.SH "th_encode_alloc"
.IX Header "th_encode_alloc"
Allocates an encoder instance.
.PP
\&\-Input:
  th_info.
.PP
\&\-Output:
  th_enc_ctx handle,
  \s-1NULL\s0 (if the encoding parameters were invalid).
.SH "th_encode_flushheader"
.IX Header "th_encode_flushheader"
\&\-Input:
  th_enc_ctx,
  th_comment,
  ogg_packet.
.PP
\&\-Output:
  > 1 (indicates that a header packet was successfully produced),
  0 (no packet was produced, and no more header packets remain),
  \s-1TH_EFAULT\s0 (_enc, _comments, or _op was \s-1NULL\s0).
.SH "th_encode_ycbcr_in"
.IX Header "th_encode_ycbcr_in"
Submits an uncompressed frame to the encoder. (if you don't have ycbcr buffer
you can try using the *unoptimized* rgb_th_encode_ycbcr_in, better you write 
your own).
.PP
\&\-Input:
  th_enc_ctx,
  th_ycbcr_buffer
.PP
\&\-Output:
  0 Success,
  \s-1TH_EFAULT\s0 _enc or _ycbcr is \s-1NULL\s0,
  \s-1TH_EINVAL\s0 buffer size does not match the frame size encoder was initialized.
.SH "th_encode_packetout"
.IX Header "th_encode_packetout"
Retrieves encoded video data packets. 
.PP
\&\-Input:
  th_enc_ctx,
  int (non\-zero value if no more uncompressed frames will be submitted),
  ogg_packet.
.PP
\&\-Output:
  > 0 a video data packet was successfully produced,
    0 no packet was produced, and no more encoded video data remains,
  \s-1TH_EFAULT\s0 _enc or _op was \s-1NULL\s0.
.SH "th_encode_free"
.IX Header "th_encode_free"
Frees an allocated encoder instance. 
.PP
\&\-Input:
  th_enc_ctx
.PP
\&\-Output:
  void
.SH "Miscellaneous Functions"
.IX Header "Miscellaneous Functions"
These functions are not found in libtheora*, but is written by the \s-1XS\s0 author
to simplify few tasks.
.SH "get_th_info"
.IX Header "get_th_info"
Returns a HashRef with th_info struct values.
.PP
\&\-Input:
  th_info
.PP
\&\-Output:
  HashRef
.SH "ycbcr_to_rgb_buffer"
.IX Header "ycbcr_to_rgb_buffer"
reads the data from the ycbcr buffer and converts to its equivalent
rgb buffer. (this is \s-1NOT\s0 an optimized code, there will be better ycbcr
to rgb convertors, some intel gpu processors have mnemonic that does
the conversion)
.PP
\&\-Input:
   th_ycbcr_buffer
.PP
\&\-Output:
  \s-1RGB\s0 string
.SH "get_th_comment"
.IX Header "get_th_comment"
return an array of comments
.PP
\&\-Input:
  th_comment
.PP
\&\-Output:
  array of comments
.SH "set_th_info"
.IX Header "set_th_info"
sets the th_info structure to default values unless specified in hash. frame_width and frame_height
is mandatory.
.PP
\&\-Input:
  Hash of elements
.PP
\&\-Output:
  void
.SH "rgb_th_encode_ycbcr_in"
.IX Header "rgb_th_encode_ycbcr_in"
Converts a rgb to ycbcr buffer. (this is not an optimized code)
.PP
\&\-Input:
  th_enc_ctx
  char * (rgb string),
  width,
  height.
.PP
\&\-Output:
  th_ycbcr_buffer
.SH "CAVEATS"
.IX Header "CAVEATS"
This Modules expects the Theora file to be contained in an Ogg container (which true for most of the theora videos
at the time of writing this module). Few of the miscellaneous functions like \fBrgb_th_encode_ycbcr_in\fR, 
\&\fBycbcr_to_rgb_buffer\fR are not optimized. This module seems to give \fBSegmentation Fault\fR if the version of libtheora
is pre\-1.0. In my system (Mac \s-1OS\s0 X, 10.5.8) when i wrote this module, I was using libtheora \f(CW@1\fR.1.1_0 (active)
and libogg \f(CW@1\fR.1.4_0 (active).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Ogg::LibOgg
<http://www.theora.org/doc/libtheora\-1.0/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Vigith Maurice, <vigith@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2011 by Vigith Maurice www.vigith.com
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.9 or,
at your option, any later version of Perl 5 you may have available.
